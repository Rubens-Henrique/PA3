README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile		  -> [course dir]/src/PA3/Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [course dir]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [course dir]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [course dir]/src/PA3/dumptype.cc
 handle_flags.c           -> [course dir]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [course dir]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [course dir]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [course dir]/src/PA3/tokens-lex.cc
 tree.cc		  -> [course dir]/src/PA3/tree.cc
 utilities.cc		  -> [course dir]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% gmake parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% gmake dotest

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	To turnin your work type:

	% gmake submit-clean

	And run the "submit" program following the instructions on the
	course web page.
	
	Running "submit" will collect the files cool.y, good.cl, bad.cl,
	good.output, bad.output, and README. Don't forget to edit the
	README file to include your write-up, and to write your own test
	cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	If you change architectures you must issue

	% gmake clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

## Design Decisions
O desenvolvimento do parser seguiu uma abordagem modular e incremental, visando garantir clareza, facilidade de depuração e aderência estrita à especificação da linguagem COOL.

As principais decisões de projeto foram:

- Utilização do arquivo cool.y como ponto central do parser
	O arquivo cool.y foi construído a partir do esqueleto fornecido. As produções já existentes para program e class_list serviram como modelo para o restante das regras gramaticais, o que garantiu consistência com o estilo inicial e integração com a infraestrutura de AST existente.

- Manutenção da ordem lógica e agrupamento de regras
	As regras foram organizadas por tipo de construção sintática (expressões, instruções de controle, definições de métodos, etc.), facilitando a manutenção e a compreensão do arquivo.

- Uso de precedência e associatividade de operadores
	Definições de precedência e associatividade foram configuradas para lidar corretamente com expressões aritméticas e booleanas, evitando ambiguidades e reduzindo a necessidade de criar regras auxiliares.

- Tratamento de erros com error tokens
	Padrões de captura de erros (error) foram inseridos em pontos estratégicos da gramática, permitindo ao parser detectar erros sintáticos comuns e recuperar o processo de parsing sempre que possível. Isso torna o parser mais robusto frente a entradas malformadas.

Essas escolhas foram feitas para maximizar a robustez do parser, reduzir a complexidade do código e garantir facilidade de depuração ao lidar com entradas inválidas.

## Correctness Argument
A validade do parser foi avaliada de acordo com os seguintes critérios:

- Cobertura das construções da linguagem COOL
	Todas as formas válidas de expressão, instruções de controle, definições de classes, métodos e atributos foram implementadas conforme descritas na especificação da linguagem.

- Geração correta da Árvore de Sintaxe Abstrata (AST)
	Cada produção da gramática foi associada diretamente a um nó apropriado da AST, garantindo que a estrutura sintática capturasse todas as informações necessárias para as fases subsequentes do compilador.

- Recuperação adequada de erros
	O parser foi projetado para reconhecer e reportar múltiplos erros numa mesma execução, em vez de interromper no primeiro erro encontrado. Isso é importante para fornecer feedback completo durante o desenvolvimento de programas.

- Testes extensivos
	A robustez foi validada por meio de um conjunto de testes positivos e negativos (detalhado abaixo), assegurando que tanto a aceitação de programas válidos quanto a rejeição de programas inválidos ocorressem corretamente.

## Adequacy of Test Cases
O conjunto de testes desenvolvido foi elaborado para cobrir de maneira sistemática e criteriosa todos os aspectos sintáticos da linguagem COOL, tanto no que se refere a construções válidas quanto ao tratamento de erros.

Os testes foram organizados em dois arquivos principais: good.cl e bad.cl.

### Arquivo good.cl
O arquivo good.cl contém exemplos que exercitam todas as construções legais da linguagem, buscando validar se o parser reconhece corretamente a sintaxe prevista. Entre os elementos testados, destacam-se:

- Definições de classes
	Testam declarações básicas de classes, heranças entre classes (inherits), e definições de atributos e métodos, assegurando que o parser reconhece diferentes formatos e níveis de complexidade.

- Inicialização de atributos
 	Verifica se atributos podem ser corretamente inicializados tanto com valores simples quanto com expressões compostas, garantindo que o parser aceita expressões arbitrárias em contextos de inicialização.

- Definições e chamadas de métodos
	Testa métodos com diferentes números de parâmetros, chamadas de métodos locais, chamadas estáticas (@) e o uso de SELF_TYPE. Esses testes validam a correta construção da AST para métodos e a gestão de escopos.

- Estruturas de controle de fluxo (if, while, case)
	Cobre todas as formas de controle de fluxo previstas pela linguagem, incluindo aninhamento de estruturas e blocos opcionais.

- Blocos e expressões let
	Testa combinações de múltiplas declarações em blocos ({}) e encadeamento de variáveis no let, assegurando a correta interpretação de agrupamentos de instruções.

- Operadores e precedência
	Avalia a correta associação e precedência entre operadores aritméticos (+, -, *, /), comparativos (<, <=, =) e booleanos (not, isvoid).

- Manipulação de tipos básicos e literais
	Exercita o reconhecimento e a manipulação de Int, Bool, String, constantes true e false, além de literais de strings e números.

Esses testes confirmam que o parser aceita construções sintaticamente válidas de forma completa e consistente.

### Arquivo bad.cl
O arquivo bad.cl foi criado para testar a capacidade do parser de identificar e reportar erros sintáticos de forma eficaz. Inclui casos como:

- Omissão de palavras-chave obrigatórias
	Ex.: falta de fi no if, ausência de in no let, e omissão de {} em blocos.

- Uso incorreto de operadores
	Ex.: operadores binários aplicados a operandos inválidos ou mal formados.

- Erros em declarações de métodos e atributos
	Ex.: ausência de tipo de retorno em métodos, parâmetros de métodos mal declarados, ou falta de : na declaração de atributos.

- Chamadas de métodos malformadas
	Ex.: ausência de parênteses obrigatórios ou número incorreto de argumentos.

- Estruturas de controle incompletas
	Ex.: case sem todas as ramificações, while sem corpo válido.

- Identificadores e literais inválidos
	Ex.: uso de caracteres não permitidos em nomes de variáveis e strings mal terminadas.

Cada erro foi planejado para testar tanto a capacidade de detecção imediata quanto a habilidade de recuperação do parser, permitindo a análise de arquivos com múltiplos problemas.

## Desafios Encontrados e Correções Feitas

Durante o desenvolvimento, tivemos alguns desafios, principalmente com as regras de sintaxe. Um erro ocorreu com o uso do ponto e vírgula (;) no final de métodos e classes, que é obrigatório no COOL, mas estava gerando erro no parser. Após revisar as produções no arquivo cool.y, ajustamos para que o ponto e vírgula fosse aceito corretamente. Também enfrentamos dificuldades com o arquivo parser-phase.cc, onde foi necessário declarar uma variável int current para resolver um erro desconhecido, o que demorou mais tempo para ser solucionado, pois não esperávamos precisar modificar esse arquivo. Além disso, tivemos um pouco de dificuldade para compreender alguns arquivos que foram copiados para o diretório, o que demandou mais tempo e análise. Também ajustamos as mensagens de erro para que ficassem mais claras durante os testes, garantindo que o parser tratasse corretamente todos os casos válidos e inválidos da linguagem COOL.
